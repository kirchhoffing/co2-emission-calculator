{"version":3,"file":"client.mjs","names":["opts: InferrableClientTypes extends TInferrable\n    ? TypeError<'Generic parameter missing in `experimental_createActionHook<HERE>()`'>\n    : CreateTRPCClientOptions<TInferrable>","handler: TRPCActionHandler<TDef>","useActionOpts?: UseTRPCActionOptions<Simplify<TDef>>","input: any","requestOptions?: TRPCRequestOptions","mutate: Result['mutate']","opts: CreateTRPCNextAppRouterOptions<TRouter>","cache","queryCacheKey","promise: Promise<unknown>"],"sources":["../../src/app-dir/create-action-hook.tsx","../../src/app-dir/client.ts"],"sourcesContent":["import type {\n  CreateTRPCClientOptions,\n  TRPCLink,\n  TRPCProcedureOptions,\n  TRPCRequestOptions,\n} from '@trpc/client';\nimport { createTRPCUntypedClient, TRPCClientError } from '@trpc/client';\nimport type {\n  CoercedTransformerParameters,\n  TransformerOptions,\n} from '@trpc/client/unstable-internals';\nimport { getTransformer } from '@trpc/client/unstable-internals';\nimport { observable } from '@trpc/server/observable';\nimport type {\n  inferClientTypes,\n  InferrableClientTypes,\n  MaybePromise,\n  Simplify,\n  TypeError,\n} from '@trpc/server/unstable-core-do-not-import';\nimport { transformResult } from '@trpc/server/unstable-core-do-not-import';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport type { TRPCActionHandler } from './server';\nimport type { ActionHandlerDef } from './shared';\nimport { isFormData } from './shared';\n\ntype MutationArgs<TDef extends ActionHandlerDef> = TDef['input'] extends void\n  ? [input?: undefined | void, opts?: TRPCProcedureOptions]\n  : [input: FormData | TDef['input'], opts?: TRPCProcedureOptions];\n\ninterface UseTRPCActionBaseResult<TDef extends ActionHandlerDef> {\n  mutate: (...args: MutationArgs<TDef>) => void;\n  mutateAsync: (...args: MutationArgs<TDef>) => Promise<TDef['output']>;\n}\n\ninterface UseTRPCActionSuccessResult<TDef extends ActionHandlerDef>\n  extends UseTRPCActionBaseResult<TDef> {\n  data: TDef['output'];\n  error?: never;\n  status: 'success';\n}\n\ninterface UseTRPCActionErrorResult<TDef extends ActionHandlerDef>\n  extends UseTRPCActionBaseResult<TDef> {\n  data?: never;\n  error: TRPCClientError<TDef['errorShape']>;\n  status: 'error';\n}\n\ninterface UseTRPCActionIdleResult<TDef extends ActionHandlerDef>\n  extends UseTRPCActionBaseResult<TDef> {\n  data?: never;\n  error?: never;\n  status: 'idle';\n}\n\ninterface UseTRPCActionLoadingResult<TDef extends ActionHandlerDef>\n  extends UseTRPCActionBaseResult<TDef> {\n  data?: never;\n  error?: never;\n  status: 'loading';\n}\n\n// ts-prune-ignore-next\nexport type UseTRPCActionResult<TDef extends ActionHandlerDef> =\n  | UseTRPCActionErrorResult<TDef>\n  | UseTRPCActionIdleResult<TDef>\n  | UseTRPCActionLoadingResult<TDef>\n  | UseTRPCActionSuccessResult<TDef>;\n\ntype ActionContext = {\n  _action: (...args: any[]) => Promise<any>;\n};\n\n// ts-prune-ignore-next\nexport function experimental_serverActionLink<\n  TInferrable extends InferrableClientTypes,\n>(\n  ...args: InferrableClientTypes extends TInferrable\n    ? [\n        TypeError<'Generic parameter missing in `experimental_createActionHook<HERE>()` or experimental_serverActionLink<HERE>()'>,\n      ]\n    : inferClientTypes<TInferrable>['transformer'] extends true\n      ? [\n          opts: TransformerOptions<{\n            transformer: true;\n          }>,\n        ]\n      : [\n          opts?: TransformerOptions<{\n            transformer: false;\n          }>,\n        ]\n): TRPCLink<TInferrable> {\n  const [opts] = args as [CoercedTransformerParameters];\n  const transformer = getTransformer(opts?.transformer);\n  return () =>\n    ({ op }) =>\n      observable((observer) => {\n        const context = op.context as ActionContext;\n\n        context\n          ._action(\n            isFormData(op.input)\n              ? op.input\n              : transformer.input.serialize(op.input),\n          )\n          .then((data) => {\n            const transformed = transformResult(data, transformer.output);\n\n            if (!transformed.ok) {\n              observer.error(TRPCClientError.from(transformed.error, {}));\n              return;\n            }\n            observer.next({\n              context: op.context,\n              result: transformed.result,\n            });\n            observer.complete();\n          })\n          .catch((cause) => {\n            observer.error(TRPCClientError.from(cause));\n          });\n      });\n}\n\ninterface UseTRPCActionOptions<TDef extends ActionHandlerDef> {\n  onSuccess?: (result: TDef['output']) => MaybePromise<void> | void;\n  onError?: (result: TRPCClientError<TDef['errorShape']>) => MaybePromise<void>;\n}\n// ts-prune-ignore-next\nexport function experimental_createActionHook<\n  TInferrable extends InferrableClientTypes,\n>(\n  opts: InferrableClientTypes extends TInferrable\n    ? TypeError<'Generic parameter missing in `experimental_createActionHook<HERE>()`'>\n    : CreateTRPCClientOptions<TInferrable>,\n) {\n  type ActionContext = {\n    _action: (...args: any[]) => Promise<any>;\n  };\n  const client = createTRPCUntypedClient(\n    opts as Exclude<typeof opts, TypeError<any>>,\n  );\n  return function useAction<TDef extends ActionHandlerDef>(\n    handler: TRPCActionHandler<TDef>,\n    useActionOpts?: UseTRPCActionOptions<Simplify<TDef>>,\n  ) {\n    const count = useRef(0);\n\n    type Result = UseTRPCActionResult<TDef>;\n    type State = Omit<Result, 'mutate' | 'mutateAsync'>;\n    const [state, setState] = useState<State>({\n      status: 'idle',\n    });\n\n    const actionOptsRef = useRef(useActionOpts);\n    actionOptsRef.current = useActionOpts;\n\n    useEffect(() => {\n      return () => {\n        // cleanup after unmount to prevent calling hook opts after unmount\n        count.current = -1;\n        actionOptsRef.current = undefined;\n      };\n    }, []);\n\n    const mutateAsync = useCallback(\n      (input: any, requestOptions?: TRPCRequestOptions) => {\n        const idx = ++count.current;\n        const context = {\n          ...requestOptions?.context,\n          _action(innerInput) {\n            return handler(innerInput);\n          },\n        } as ActionContext;\n\n        setState({\n          status: 'loading',\n        });\n        return client\n          .mutation('serverAction', input, {\n            ...requestOptions,\n            context,\n          })\n          .then(async (data) => {\n            await actionOptsRef.current?.onSuccess?.(data as any);\n            if (idx !== count.current) {\n              return;\n            }\n            setState({\n              status: 'success',\n              data: data as any,\n            });\n          })\n          .catch(async (error) => {\n            await actionOptsRef.current?.onError?.(error);\n            throw error;\n          })\n          .catch((error) => {\n            if (idx !== count.current) {\n              return;\n            }\n            setState({\n              status: 'error',\n              error: TRPCClientError.from(error, {}),\n            });\n            throw error;\n          });\n      },\n      [handler],\n    ) as Result['mutateAsync'];\n\n    const mutate: Result['mutate'] = useCallback(\n      (...args: any[]) => {\n        void (mutateAsync as any)(...args).catch(() => {\n          // ignored\n        });\n      },\n      [mutateAsync],\n    );\n\n    return useMemo(\n      () => ({\n        ...state,\n        mutate,\n        mutateAsync,\n      }),\n      [mutate, mutateAsync, state],\n    ) as Result;\n  };\n}\n","import type { TRPCClient } from '@trpc/client';\nimport {\n  clientCallTypeToProcedureType,\n  createTRPCUntypedClient,\n} from '@trpc/client';\nimport type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport { createRecursiveProxy } from '@trpc/server/unstable-core-do-not-import';\nimport type { CreateTRPCNextAppRouterOptions } from './shared';\n\nexport {\n  // ts-prune-ignore-next\n  experimental_createActionHook,\n  // ts-prune-ignore-next\n  experimental_serverActionLink,\n  // ts-prune-ignore-next\n  type UseTRPCActionResult,\n} from './create-action-hook';\n\ntype QueryResult = {\n  data?: unknown;\n  error?: unknown;\n  promise?: Promise<unknown>;\n};\n\n// ts-prune-ignore-next\nexport function experimental_createTRPCNextAppDirClient<\n  TRouter extends AnyRouter,\n>(opts: CreateTRPCNextAppRouterOptions<TRouter>) {\n  const client = createTRPCUntypedClient<TRouter>(opts.config());\n  // const useProxy = createUseProxy<TRouter>(client);\n\n  const cache = new Map<string, QueryResult>();\n\n  return createRecursiveProxy<TRPCClient<TRouter>>(({ path, args }) => {\n    // const pathCopy = [key, ...path];\n    const pathCopy = [...path];\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const procedureType = clientCallTypeToProcedureType(pathCopy.pop()!);\n\n    if (procedureType === 'query') {\n      const queryCacheKey = JSON.stringify([path, args[0]]);\n      const cached = cache.get(queryCacheKey);\n\n      if (cached?.promise) {\n        return cached.promise;\n      }\n    }\n\n    const fullPath = pathCopy.join('.');\n\n    const promise: Promise<unknown> = (client as any)[procedureType](\n      fullPath,\n      ...args,\n    );\n    if (procedureType !== 'query') {\n      return promise;\n    }\n\n    const queryCacheKey = JSON.stringify([path, args[0]]);\n\n    cache.set(queryCacheKey, {\n      promise,\n    });\n\n    return promise;\n  });\n  // });\n}\n"],"mappings":"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"}